import numpy as np

class Node:
    def __init__(self, x_centre, y_centre, x_stepsize, y_stepsize, value=0.0):
        self.u_old = value
        self.u_new = 0.0
        
        self.neighbours = []
        self.flux_sum = 0.0
        
        self.volume = x_stepsize * y_stepsize
        
        pass
    
    def setValue(self, value):
        '''For initial conditions or flux flow-in.'''
        self.newValue = value
        
    def position(self):
        return np.array([self.x_centre, self.y_centre])
    
class Edge:
    '''An edge connects two nodes. It models the boundary BETWEEN these nodes. So the graphical representation will be CONFUSING! The graph edge would be drawn perpendicularly to the volume edge.'''
    def __init__(self, node1: Node, node2: Node, boundary_type=None):
        self.node1 = node1
        self.node2 = node2,
        self.normal = self.calculateNormal(),
        self.length = self.calculateLength(),
        self.boundary_type = boundary_type 
        
    def calculateNormal(self):
        '''The normal, oriented from node1 to node2'''
        direction = self.node2.position()-self.node1.position()
        normal = direction / np.hypot(direction)
        return normal
    
    def calculateLength(self):
        return np.hypot(self.node2.position()-self.node1.position())
    
    def compute_flux(self):
        return
        
class Grid:
    def __init__(self):
        self.nodes = []
        self.edges = []
        
    def compute_fluxes(self):
        for edge in self.edges():
            edge.compute_flux()
            
    def update_nodes(self, dt):
        for node in self.nodes:
            node.u_new=node.u_old + dt * (node.flux_sum / node.volume)
            node.flux_sum = 0.0
    
    def swap_fields(self):
        for node in self.nodes:
            node.u_old = node.u_new
    